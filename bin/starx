#!/usr/bin/env ruby
require 'io/wait'

WIDTH = %x{tput cols}.strip.to_i
HEIGHT = %x{tput lines}.strip.to_i - 3

class Starx
	def initialize
		system 'tput civis'
		@cells = {}
		for y in 1..HEIGHT
			y = "0#{y}" if y < 10
			for x in 1..WIDTH
				x = "0#{x}" if x < 10
				key = "#{y}.#{x}"
				@cells[key] = :empty
			end
		end
	
		player_key = "#{ HEIGHT / 2 }.05"
		@cells[player_key] = :player

		display
		puts " "
		
		@tickcount = 0
		@score = 0
	end

	def display
		# sort the hash so it prints out correctly
		@cells = @cells.sort_by { |key,_| key.to_f }	

		score_length = "SCORE: #{@score}  ".length
		print "\e[32mSCORE:\e[0m #{@score}  "
		(WIDTH - score_length).times {print '*'}
		@cells.each do |position, value|
			position_array = position.split('.')
			y = position_array[0]
			x = position_array[1]
			if x != 0 && value == :full
				print "*"
			elsif x != 0 && value == :empty
				print " "
			elsif x != 0 && value == :player
				print "\e[31m>\e[0m"
			end
		end
		WIDTH.times {print '*'}

	end

	def tick
		@tickcount += 1
		if @tickcount >= WIDTH && @tickcount % 20 == 0
			@score += 1 
		end

		new_cells
		keys

		if collision?
			try_again_screen
		else
			display
		end
	end

	def new_cells
		new_cells = {}
		@cells.each do |position, value|
			position_array = position.split('.')
			y = position_array[0].to_i
			x = position_array[1].to_i - 1
			x = "0#{x}" if x < 10
			y = "0#{y}" if y < 10
			unless x.to_i == 0
				new_key = "#{y}.#{x}"
				new_cells[new_key] = value
			end
		end

		# switch player cell with empty cell to the right 
		player_before_switch = new_cells.select {|_,v| v == :player}.keys[0].split('.')
		x_player_before_switch = player_before_switch[1].to_i
		y_player_before_switch = player_before_switch[0]

		x_cell_after_player = x_player_before_switch + 1

		x_player_before_switch = "0#{x_player_before_switch}" if x_player_before_switch < 10
		x_cell_after_player = "0#{x_cell_after_player}" if x_cell_after_player < 10

		cell_after_player = "#{y_player_before_switch}.#{x_cell_after_player}"
		player_before_switch = player_before_switch.join('.')

		new_cells.delete(cell_after_player)
		new_cells.delete(player_before_switch)
		new_cells[cell_after_player] = :player
		new_cells[player_before_switch] = :empty

		# new column
		if  @tickcount % 20 == 0 || @tickcount == 1
			x = WIDTH
			space = HEIGHT / 5
			random = rand(HEIGHT - space)
			for y in 1..random
				y = "0#{y}" if y < 10
				key = "#{y}.#{x}"
				new_cells[key] = :full
			end
			for y in random..(random + space)
				y = "0#{y}" if y < 10	
				key = "#{y}.#{x}"
				new_cells[key] = :empty
			end
			for y in (random + space)..HEIGHT
				key = "#{y}.#{x}"
				new_cells[key] = :full
			end
		else
			x = WIDTH
			for y in 1..HEIGHT
				key = "#{y}.#{x}"
				new_cells[key] = :empty
			end
		end

		@cells = new_cells
	end
	
	def move_up!
		player_key = @cells.select {|_,v| v == :player}.keys[0].split('.')
		player_x = player_key[1]
		player_y = player_key[0].to_i

		cell_x = player_x
		cell_y = player_y - 1
		if cell_y < 10
			cell_y = "0#{cell_y}" 
		else
			cell_y.to_s
		end
		player_y = player_key[0]

		player_new_key = "#{player_y}.#{player_x}"
		cell_key = "#{cell_y}.#{cell_x}"

		@cells.delete(player_new_key)
		@cells.delete(cell_key)

		@cells[player_new_key] = :empty
		@cells[cell_key] = :player
	end

	def move_down!	
		player_key = @cells.select {|_,v| v == :player}.keys[0].split('.')
		player_x = player_key[1]
		player_y = player_key[0].to_i

		cell_x = player_x
		cell_y = player_y + 1
		if cell_y < 10
			cell_y = "0#{cell_y}" 
		else
			cell_y.to_s
		end
		player_y = player_key[0]

		player_new_key = "#{player_y}.#{player_x}"
		cell_key = "#{cell_y}.#{cell_x}"

		@cells.delete(player_new_key)
		@cells.delete(cell_key)

		@cells[player_new_key] = :empty
		@cells[cell_key] = :player
	end

	def collision?
		collision = false
		player_position = @cells.select {|_,v| v == :player}.keys[0].split('.')
		player_x = player_position[1].to_i
		player_y = player_position[0]
		cell_in_front_x = player_x + 1
		cell_in_front_x = "0#{cell_in_front_x}" if cell_in_front_x < 10
		cell_in_front = "#{player_y}.#{cell_in_front_x}"

		value_of_cell_in_front = @cells.select {|k, v| k == cell_in_front}.values[0]
		if value_of_cell_in_front == :full
			collision = true
		end
		collision
	end
			
	def keys
		c = read_char
			case c
			when 'q'
				system 'tput cnorm'
				Process.exit! true
			when "\e[A"
				move_up!
			when "\e[B"
				move_down!
			end
	end

	def read_char
		begin
			state = `stty -g`
			`stty raw -echo isig`
			c = nil
			if $stdin.ready?
				c = $stdin.getc.chr
				if c == "\e"
					extra_thread = Thread.new do
						c += $stdin.getc.chr
						c += $stdin.getc.chr
					end
					extra_thread.join(0.00001)
					extra_thread.kill
				end
			end
		ensure
			system "stty #{state}"
		end
		c
		# TODO: Hide non-blocking io
	end

	def read_char_menu
		begin
			state = `stty -g`
			`stty raw -echo isig`
			c = $stdin.getc.chr if $stdin
		ensure
			system "stty #{state}"
		end
		c
	end

	def keys_menu
		c = read_char_menu
		case c
		when 'a'
			Starx.new.play
		when 'q'
			system 'tput cnorm'
			system 'clear'
			Process.exit! true
		else
			try_again_screen
		end
	end

	def try_again_screen
		(HEIGHT / 2).times{ WIDTH.times { print '*' } }
		
		num = WIDTH / 2 - 12
		num.times{ print '*' }
		print "  \e[31m  You died. Haha!  \e[0m    "
		(num * 2).times{ print '*' }
		print " \e[32m Your score: #{@score}\e[0m"
		print '         '
		(num * 2).times{ print '*' }
		print " To try again hit 'a'   "
		(num * 2).times{ print '*' }
		print " To quit hit  'q'       "
		(num - 1).times{ print '*' }

		(HEIGHT / 2 - 2).times{ WIDTH.times { print '*' } }
		puts ''
		keys_menu	

		# TODO: Add best scores
	end

	def play
		loop do
			tick
			sleep 0.04
			system 'clear'
		end
	end
	#
	# TODO: score count in hidden file and displayed on screen
end

g = Starx.new
g.play
