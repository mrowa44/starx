#!/usr/bin/env ruby
require 'io/wait'

WIDTH = %x{tput cols}.strip.to_i
HEIGHT = %x{tput lines}.strip.to_i - 3

class Starx
	def initialize
		system 'tput civis'
		@cells = {}
		for y in 1..HEIGHT
			y = "0#{y}" if y < 10
			for x in 1..WIDTH
				x = "0#{x}" if x < 10
				key = "#{y}.#{x}"
				@cells[key] = :empty
			end
		end
	
		player_key = "#{ HEIGHT / 2 }.05"
		@cells[player_key] = :player

		display
		puts " "
		
		@tickcount = 0
		@score = 0
	end

	def display
		# sort the hash so it prints out correctly
		@cells = @cells.sort_by { |key,_| key.to_f }	

		score_length = "SCORE: #{@score}  ".length
		print "\e[32mSCORE:\e[0m #{@score}  "
		(WIDTH - score_length).times {print '*'}
		@cells.each do |position, value|
			position_array = position.split('.')
			y = position_array[0]
			x = position_array[1]
                        case value
                        when :full
                            print '*'
                        when :empty
                            print " "
                        when :player
                            print "\e[31m>\e[0m"
                        end
		end
		WIDTH.times {print '*'}

	end

	def tick
		@tickcount += 1
		if @tickcount >= WIDTH && @tickcount % 20 == 0
			@score += 1 
		end

		new_cells
		keys

		if collision?
			try_again_screen
		else
			display
		end
	end

	def new_cells
		new_cells = {}
		@cells.each do |position, value|
			position_array = position.split('.')
			y = position_array[0].to_i
			x = position_array[1].to_i - 1
			x = "0#{x}" if x < 10
			y = "0#{y}" if y < 10
			unless x.to_i == 0
				new_key = "#{y}.#{x}"
				new_cells[new_key] = value
			end
		end

		# switch player cell with empty cell to the right 
		player_before_switch = new_cells.select {|_,v| v == :player}.keys[0].split('.')
		x_player_before_switch = player_before_switch[1].to_i
		y_player_before_switch = player_before_switch[0]

		x_cell_after_player = x_player_before_switch + 1

		x_player_before_switch = "0#{x_player_before_switch}" if x_player_before_switch < 10
		x_cell_after_player = "0#{x_cell_after_player}" if x_cell_after_player < 10

		cell_after_player = "#{y_player_before_switch}.#{x_cell_after_player}"
		player_before_switch = player_before_switch.join('.')

		new_cells.delete(cell_after_player)
		new_cells.delete(player_before_switch)
		new_cells[cell_after_player] = :player
		new_cells[player_before_switch] = :empty

		# new column
		if  @tickcount % 20 == 0 || @tickcount == 1
			x = WIDTH
			space = HEIGHT / 5
			random = rand(HEIGHT - space)
			for y in 1..random
				y = "0#{y}" if y < 10
				key = "#{y}.#{x}"
				new_cells[key] = :full
			end
			for y in random..(random + space)
				y = "0#{y}" if y < 10	
				key = "#{y}.#{x}"
				new_cells[key] = :empty
			end
			for y in (random + space)..HEIGHT
				key = "#{y}.#{x}"
				new_cells[key] = :full
			end
		else
			x = WIDTH
			for y in 1..HEIGHT
				key = "#{y}.#{x}"
				new_cells[key] = :empty
			end
		end

		@cells = new_cells
	end
	
	def move_up!
            switch_player_with(1,0)
	end

	def move_down!	
            switch_player_with(-1,0)
	end

        def move_forward!
            switch_player_with(0,-1)
        end
        
        def move_backward!
            switch_player_with(0,1)
        end

        def switch_player_with(y,x)
            player_x = find_player[1].to_i
            player_y = find_player[0].to_i
            cell_x = player_x - x
            cell_y = player_y - y

            player_x = "0#{player_x}" if player_x < 10
            player_y = "0#{player_y}" if player_y < 10
            cell_x = "0#{cell_x}" if cell_x < 10
            cell_y = "0#{cell_y}" if cell_y < 10

            cell_key = "#{cell_y}.#{cell_x}"
            player_key = "#{player_y}.#{player_x}"

            @cells.delete(cell_key)
            @cells.delete(player_key)
            @cells[player_key] = :empty
            @cells[cell_key] = :player
        end

        def find_player
            @cells.select {|_,v| v == :player}.keys[0].split('.')
        end

	def collision?
		collision = false
		player_x = find_player[1].to_i
		player_y = find_player[0]
		cell_in_front_x = player_x + 1
		cell_in_front_x = "0#{cell_in_front_x}" if cell_in_front_x < 10
		cell_in_front = "#{player_y}.#{cell_in_front_x}"

		value_of_cell_in_front = @cells.select {|k, v| k == cell_in_front}.values[0]
		if value_of_cell_in_front == :full
			collision = true
		end
		collision
	end
			
	def keys
		c = read_char
			case c
			when 'q'
				system 'tput cnorm'
				Process.exit! true
			when "\e[A"
				move_up!
			when "\e[B"
				move_down!
                        when "\e[C"
                                move_forward!
                        when "\e[D"
                                move_backward!
			end
	end

	def read_char
		begin
                    system 'stty raw -echo'
                    if $stdin.ready?
                        c = $stdin.getc.chr
                        if c == "\e"
                            extra_thread = Thread.new do
                                c += $stdin.getc.chr
                                c += $stdin.getc.chr
                            end
                        extra_thread.join 0.00001
                        extra_thread.kill
                        end
                    end
                ensure
                    system 'stty -raw echo'
                end
                c
        end

	def read_char_menu
		begin
			system 'stty raw -echo'
			c = $stdin.getc.chr
		ensure
			system 'stty -raw echo'
		end
		c
	end

	def keys_menu
		c = read_char_menu
		case c
		when 'a'
			Starx.new.play
		when 'q'
			system 'tput cnorm'
			system 'clear'
			Process.exit! true
		else
			try_again_screen
		end
	end

	def try_again_screen
		(HEIGHT / 2).times{ WIDTH.times { print '*' } }
		
		num = WIDTH / 2 
                (WIDTH / 2 - 10).times{ print ' '}
		print "\e[31m You died. Haha!\e[0m\n"
                puts ''
                (WIDTH / 2 - 10).times{ print ' '}
		print "\e[32m Your score: #{@score}\e[0m\n"
                puts ''
                puts ''
                (WIDTH / 2 - 10).times{ print ' '}
		print "To try again hit 'a'\n"
                (WIDTH / 2 - 10).times{ print ' '}
		print "To quit hit  'q'\n"

		(HEIGHT / 2 - 1).times{ WIDTH.times { print '*' } }
		puts ''
		keys_menu	

	end

	def play
		loop do
                    begin
			tick
			sleep 0.04
			system 'clear'
                    rescue Interrupt
                        system 'tput cnorm'
                        system 'clear'
                        Process.exit! true
                    end
                 end
	end
end

g = Starx.new
g.play
